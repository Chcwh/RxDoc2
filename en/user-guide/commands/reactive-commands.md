# Reactive Commands

Reactive commands also encapsulate logic to execute in response to user actions, but they do so via a reactive API. For example, instead of querying the command for its executability, you can use the `CanExecute` property, which is of type `IObservable<bool>`. Similarly, an `IsExecuting` property (also of type `IObservable<bool>`) tells you whether the command is currently executing, which could be a useful trigger to enable an activity animation, for example. And when you execute the command, you get back an `IObservable<TResult>`, where `TResult` is the "result" of executing your command (often just `Unit` if your command doesn't need to return anything of importance).

The fact that executing a command returns an observable of the result and not the result itself makes it clear that reactive commands are inherently asynchronous. You can kick off a CPU- or I/O-bound command without blocking your UI. Once completed, the result ticks through the observable and your UI can respond accordingly. Whilst the command is executing, it is unavailable (i.e. `CanExecute` will tick `false`). Thus, any UI elements bound to that command will automatically disable themselves whilst the command is executing.

Finally, reactive commands are themselves observable. Whenever any execution of the command completes, its value is observable by subscribing directly to the command.
